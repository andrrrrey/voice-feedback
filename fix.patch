diff --git a/templates/public_form.html b/templates/public_form.html
index 4aea8262cb0e65c4dfd0c462a53031f7a7acc729..4bd62bbd763017e3b3491b27a5f045fa2c931303 100644
--- a/templates/public_form.html
+++ b/templates/public_form.html
@@ -138,164 +138,288 @@
       <div class="info-box" id="aiText"></div>
       <div class="btn-row">
         <button id="editBtn" class="btn" type="button">Редактировать и отправить</button>
         <button class="btn secondary" type="button" onclick="showStep(1)">Записать ещё раз</button>
       </div>
     </div>
 
     <div class="card step" id="step3">
       <h2>Шаг 3. Отредактируйте текст и отправьте</h2>
       <textarea id="finalText" placeholder="Добавьте детали или исправьте текст..."></textarea>
       <div class="btn-row">
         <button id="sendBtn" class="btn" type="button">Отправить отзыв</button>
         <button class="btn secondary" type="button" onclick="showStep(1)">Начать заново</button>
       </div>
       <p id="sendStatus" class="status"></p>
     </div>
   </div>
 
   <script>
     const BASE = '/voice-feedback';
     const companySlug = "{{ company.slug }}";
 
     let mediaRecorder;
     let recorderMime;
     let audioChunks = [];
+    let useFallback = false;
+    let fallbackContext = null;
+    let fallbackProcessor = null;
+    let fallbackSource = null;
+    let fallbackStream = null;
+    let fallbackBuffers = [];
     let reviewId = null;
     let normalizedText = "";
 
     const step1 = document.getElementById("step1");
     const step2 = document.getElementById("step2");
     const step3 = document.getElementById("step3");
 
     function showStep(n) {
       [step1, step2, step3].forEach((el, i) => {
         el.classList.toggle("active", i === (n-1));
       });
     }
 
     const startBtn = document.getElementById("startBtn");
     const stopBtn = document.getElementById("stopBtn");
     const recordStatus = document.getElementById("recordStatus");
     const userNameInput = document.getElementById("userName");
     const aiText = document.getElementById("aiText");
     const sentimentSpan = document.getElementById("sentimentSpan");
     const editBtn = document.getElementById("editBtn");
     const finalText = document.getElementById("finalText");
     const sendBtn = document.getElementById("sendBtn");
     const sendStatus = document.getElementById("sendStatus");
 
     startBtn.onclick = async () => {
       audioChunks = [];
-    
-      let preferredMime = null;
-    
-      // 1. Пробуем ogg/opus (идеальный вариант для SpeechKit)
-      if (MediaRecorder.isTypeSupported('audio/ogg;codecs=opus')) {
-        preferredMime = 'audio/ogg;codecs=opus';
-      } else if (MediaRecorder.isTypeSupported('audio/ogg; codecs=opus')) {
-        // иногда браузеры чувствительны к пробелам
-        preferredMime = 'audio/ogg; codecs=opus';
-      }
-    
-      // 2. Если ogg не поддерживается — пробуем webm/opus (часто так в Chrome)
-      if (!preferredMime) {
-        if (MediaRecorder.isTypeSupported('audio/webm;codecs=opus')) {
-          preferredMime = 'audio/webm;codecs=opus';
-        } else if (MediaRecorder.isTypeSupported('audio/webm')) {
-          preferredMime = 'audio/webm';
-        }
-      }
-    
-      // 3. Если ни один формат не подошёл — реально нет поддержки MediaRecorder
-      if (!preferredMime) {
-        recordStatus.textContent = "Ваш браузер не поддерживает запись аудио через MediaRecorder. Попробуйте другой браузер (Chrome/Edge/Firefox на компьютере).";
+      fallbackBuffers = [];
+      useFallback = false;
+
+      if (typeof MediaRecorder === 'undefined') {
+        await startFallbackRecorder();
         return;
       }
-    
+
+      let preferredMime = null;
+
       try {
+        // 1. Пробуем ogg/opus (идеальный вариант для SpeechKit)
+        if (MediaRecorder.isTypeSupported('audio/ogg;codecs=opus')) {
+          preferredMime = 'audio/ogg;codecs=opus';
+        } else if (MediaRecorder.isTypeSupported('audio/ogg; codecs=opus')) {
+          // иногда браузеры чувствительны к пробелам
+          preferredMime = 'audio/ogg; codecs=opus';
+        }
+
+        // 2. Если ogg не поддерживается — пробуем webm/opus (часто так в Chrome)
+        if (!preferredMime) {
+          if (MediaRecorder.isTypeSupported('audio/webm;codecs=opus')) {
+            preferredMime = 'audio/webm;codecs=opus';
+          } else if (MediaRecorder.isTypeSupported('audio/webm')) {
+            preferredMime = 'audio/webm';
+          }
+        }
+
+        // 3. Если ни один формат не подошёл — включаем ручной рекордер
+        if (!preferredMime) {
+          await startFallbackRecorder();
+          return;
+        }
+
         const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
-    
+
         recorderMime = preferredMime;
-    
+
         mediaRecorder = new MediaRecorder(stream, { mimeType: recorderMime });
         mediaRecorder.ondataavailable = (e) => {
           audioChunks.push(e.data);
         };
         mediaRecorder.onstop = onRecordStop;
         mediaRecorder.start();
         recordStatus.textContent = "Запись идёт...";
         startBtn.disabled = true;
         stopBtn.disabled = false;
       } catch (e) {
         console.error(e);
-        recordStatus.textContent = "Не удалось получить доступ к микрофону.";
+        await startFallbackRecorder();
       }
     };
 
     stopBtn.onclick = () => {
-      if (mediaRecorder && mediaRecorder.state !== "inactive") {
+      if (useFallback) {
+        stopFallbackRecorder();
+      } else if (mediaRecorder && mediaRecorder.state !== "inactive") {
         mediaRecorder.stop();
       }
       stopBtn.disabled = true;
       startBtn.disabled = false;
       recordStatus.textContent = "Обработка записи...";
     };
 
     async function onRecordStop() {
       const blob = new Blob(audioChunks, { type: recorderMime || "audio/webm" });
+      await uploadAudioBlob(blob, recorderMime || "audio/webm");
+    }
+
+    async function uploadAudioBlob(blob, mimeType) {
       const formData = new FormData();
-    
-      const filename = (recorderMime && recorderMime.startsWith("audio/ogg"))
-        ? "record.ogg"
-        : "record.webm";
-    
+
+      let filename = "record.webm";
+
+      if (mimeType && mimeType.startsWith("audio/ogg")) {
+        filename = "record.ogg";
+      } else if (mimeType && mimeType.startsWith("audio/wav")) {
+        filename = "record.wav";
+      }
+
       formData.append("audio", blob, filename);
       formData.append("user_name", userNameInput.value || "");
-    
+
       recordStatus.textContent = "Обработка записи...";
-    
+
       const res = await fetch(`${BASE}/api/public/${companySlug}/upload-audio`, {
         method: "POST",
         body: formData
       });
-    
+
       if (!res.ok) {
         recordStatus.textContent = "Ошибка при отправке аудио.";
         return;
       }
-    
+
       const data = await res.json();
       reviewId = data.review_id;
       normalizedText = data.normalized_text;
       aiText.textContent = data.normalized_text;
       sentimentSpan.textContent = data.sentiment;
-    
+
       recordStatus.textContent = "";
       showStep(2);
     }
 
+    async function startFallbackRecorder() {
+      try {
+        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
+        const AudioContextClass = window.AudioContext || window.webkitAudioContext;
+
+        fallbackContext = new AudioContextClass();
+        fallbackStream = stream;
+
+        fallbackSource = fallbackContext.createMediaStreamSource(stream);
+        fallbackProcessor = fallbackContext.createScriptProcessor(4096, 1, 1);
+        const silentGain = fallbackContext.createGain();
+        silentGain.gain.value = 0;
+
+        fallbackProcessor.onaudioprocess = (event) => {
+          fallbackBuffers.push(new Float32Array(event.inputBuffer.getChannelData(0)));
+        };
+
+        fallbackSource.connect(fallbackProcessor);
+        fallbackProcessor.connect(silentGain);
+        silentGain.connect(fallbackContext.destination);
+
+        useFallback = true;
+        recordStatus.textContent = "Запись идёт...";
+        startBtn.disabled = true;
+        stopBtn.disabled = false;
+      } catch (error) {
+        console.error(error);
+        recordStatus.textContent = "Не удалось получить доступ к микрофону.";
+      }
+    }
+
+    function stopFallbackRecorder() {
+      if (!fallbackContext || !fallbackProcessor) {
+        recordStatus.textContent = "Не удалось завершить запись.";
+        return;
+      }
+
+      fallbackProcessor.disconnect();
+      if (fallbackSource) fallbackSource.disconnect();
+
+      if (fallbackStream) {
+        fallbackStream.getTracks().forEach((track) => track.stop());
+      }
+
+      const wavBlob = encodeWAV(fallbackBuffers, fallbackContext.sampleRate);
+
+      fallbackBuffers = [];
+
+      if (fallbackContext && typeof fallbackContext.close === 'function') {
+        fallbackContext.close();
+      }
+
+      fallbackContext = null;
+      fallbackProcessor = null;
+      fallbackSource = null;
+      fallbackStream = null;
+
+      uploadAudioBlob(wavBlob, "audio/wav");
+    }
+
+    function encodeWAV(buffers, sampleRate) {
+      const totalLength = buffers.reduce((sum, buffer) => sum + buffer.length, 0);
+      const wavBuffer = new ArrayBuffer(44 + totalLength * 2);
+      const view = new DataView(wavBuffer);
+
+      // RIFF chunk descriptor
+      writeString(view, 0, 'RIFF');
+      view.setUint32(4, 36 + totalLength * 2, true);
+      writeString(view, 8, 'WAVE');
+
+      // fmt sub-chunk
+      writeString(view, 12, 'fmt ');
+      view.setUint32(16, 16, true); // Subchunk1Size
+      view.setUint16(20, 1, true); // AudioFormat (PCM)
+      view.setUint16(22, 1, true); // NumChannels
+      view.setUint32(24, sampleRate, true); // SampleRate
+      view.setUint32(28, sampleRate * 2, true); // ByteRate
+      view.setUint16(32, 2, true); // BlockAlign
+      view.setUint16(34, 16, true); // BitsPerSample
+
+      // data sub-chunk
+      writeString(view, 36, 'data');
+      view.setUint32(40, totalLength * 2, true);
+
+      let offset = 44;
+      buffers.forEach((buffer) => {
+        for (let i = 0; i < buffer.length; i++, offset += 2) {
+          const sample = Math.max(-1, Math.min(1, buffer[i]));
+          view.setInt16(offset, sample < 0 ? sample * 0x8000 : sample * 0x7fff, true);
+        }
+      });
+
+      return new Blob([view], { type: 'audio/wav' });
+    }
+
+    function writeString(view, offset, string) {
+      for (let i = 0; i < string.length; i++) {
+        view.setUint8(offset + i, string.charCodeAt(i));
+      }
+    }
+
     editBtn.onclick = () => {
       finalText.value = normalizedText;
       showStep(3);
     };
 
     sendBtn.onclick = async () => {
       sendStatus.textContent = "Отправка...";
       const body = {
         text: finalText.value,
         user_name: userNameInput.value || null,
       };
 
       const res = await fetch(`${BASE}/api/public/reviews/${reviewId}/finalize`, {
         method: "POST",
         headers: { "Content-Type": "application/json" },
         body: JSON.stringify(body)
       });
 
       const data = await res.json();
       if (data.status === "ok" && data.email_sent) {
         sendStatus.textContent = "Спасибо! Ваш отзыв отправлен.";
         sendBtn.disabled = true;
       } else {
         sendStatus.textContent = "Отзыв сохранён, но письмо не удалось отправить (ошибка email).";
       }
