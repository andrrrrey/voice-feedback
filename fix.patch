diff --git a/templates/public_form.html b/templates/public_form.html
index 4bd62bbd763017e3b3491b27a5f045fa2c931303..520accdb0f095467af2b4b68acf65f997a9eca16 100644
--- a/templates/public_form.html
+++ b/templates/public_form.html
@@ -1,153 +1,197 @@
 <!DOCTYPE html>
 <html lang="ru">
 <head>
   <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width, initial-scale=1">
   <title>Оставить голосовой отзыв — {{ company.name }}</title>
   <style>
     :root {
-      --bg: #f5f6fb;
-      --card: #ffffff;
-      --border: #e5e7eb;
-      --muted: #6b7280;
-      --text: #0f172a;
-      --primary: #2563eb;
-      --primary-hover: #1d4ed8;
+      --bg-start: #efe4ff;
+      --bg-end: #d9c2ff;
+      --card: rgba(255, 255, 255, 0.9);
+      --border: #b388ff;
+      --muted: #4a3b63;
+      --text: #2c1f3a;
+      --primary: #7b33c8;
+      --primary-hover: #652aa4;
     }
     body {
       font-family: 'Inter', system-ui, -apple-system, sans-serif;
       margin: 0;
       min-height: 100vh;
-      background: radial-gradient(circle at 0% 0%, #dbeafe 0, rgba(219,234,254,0) 35%),
-                  radial-gradient(circle at 100% 20%, #c7d2fe 0, rgba(199,210,254,0) 30%),
-                  var(--bg);
+      background: linear-gradient(160deg, var(--bg-start), var(--bg-end));
       color: var(--text);
       padding: 24px;
       box-sizing: border-box;
+      display: flex;
+      justify-content: center;
+      align-items: flex-start;
     }
     .container {
       max-width: 760px;
+      width: 100%;
       margin: 0 auto 32px;
     }
     .card {
       background: var(--card);
       border-radius: 14px;
       padding: 20px;
-      box-shadow: 0 10px 40px rgba(15, 23, 42, 0.08);
-      border: 1px solid var(--border);
+      box-shadow: 0 14px 36px rgba(82, 0, 109, 0.15);
+      border: 2px solid var(--border);
       margin-top: 16px;
     }
     h1 { margin: 0 0 6px; font-size: 26px; letter-spacing: -0.02em; }
     h2 { margin: 0 0 12px; font-size: 20px; }
-    p { margin: 6px 0 12px; color: var(--muted); }
+    p { margin: 6px 0 12px; color: var(--muted); line-height: 1.5; }
     .logo {
       max-height: 90px;
       margin: 12px 0 4px;
-    }    .step { display: none; }
+    }
+    .step { display: none; }
     .step.active { display: block; }
     .input-group { margin: 10px 0 16px; }
-    label { font-weight: 600; display: block; margin-bottom: 6px; color: #1f2937; }
+    label { font-weight: 700; display: block; margin-bottom: 8px; color: var(--text); }
     input[type="text"], textarea {
       width: 100%;
       border-radius: 12px;
-      border: 1px solid var(--border);
-      padding: 12px 14px;
+      border: 2px solid var(--border);
+      padding: 14px 16px;
       font-size: 15px;
       box-sizing: border-box;
-      background: #f8fafc;
+      background: rgba(255, 255, 255, 0.9);
       transition: border-color 0.15s, box-shadow 0.15s;
     }
     input:focus, textarea:focus {
       outline: none;
       border-color: var(--primary);
-      box-shadow: 0 0 0 3px rgba(37,99,235,0.2);
+      box-shadow: 0 0 0 4px rgba(123, 51, 200, 0.25);
       background: #fff;
     }
     textarea { min-height: 160px; resize: vertical; }
-    .btn-row { display: flex; gap: 10px; flex-wrap: wrap; margin-top: 6px; }
+    .btn-row { display: flex; gap: 10px; flex-wrap: wrap; margin-top: 12px; }
     .btn {
       padding: 10px 16px;
-      border: none;
+      border: 2px solid var(--primary);
       border-radius: 12px;
       cursor: pointer;
       font-weight: 700;
       color: #fff;
       background: linear-gradient(135deg, var(--primary), var(--primary-hover));
-      box-shadow: 0 12px 30px rgba(37, 99, 235, 0.25);
-      transition: transform 0.1s ease, box-shadow 0.2s ease;
+      box-shadow: 0 12px 30px rgba(101, 42, 164, 0.25);
+      transition: transform 0.15s ease, box-shadow 0.2s ease, background 0.2s ease;
     }
     .btn.secondary {
-      background: #6b7280;
-      box-shadow: none;
+      background: linear-gradient(135deg, #9a88c7, #7b33c8);
+      border-color: #9a88c7;
+      box-shadow: 0 10px 26px rgba(122, 102, 176, 0.2);
     }
     .btn:disabled { opacity: 0.6; cursor: not-allowed; }
     .btn:hover:not(:disabled) { transform: translateY(-1px); }
     .info-box {
-      background: #eef2ff;
-      color: #4338ca;
-      border: 1px solid #c7d2fe;
-      padding: 10px 12px;
-      border-radius: 10px;
+      background: rgba(123, 51, 200, 0.08);
+      color: #4a2c7b;
+      border: 1px solid rgba(123, 51, 200, 0.25);
+      padding: 12px 14px;
+      border-radius: 12px;
       font-size: 14px;
       margin-top: 8px;
     }
     .status { margin-top: 8px; font-size: 14px; color: var(--muted); }
 
+    .mic-wrapper {
+      display: flex;
+      justify-content: center;
+      margin: 18px 0 6px;
+    }
+    .mic-button {
+      width: 140px;
+      height: 140px;
+      border-radius: 50%;
+      border: none;
+      display: grid;
+      place-items: center;
+      background: linear-gradient(145deg, var(--primary), var(--primary-hover));
+      color: #fff;
+      box-shadow: 0 20px 40px rgba(101, 42, 164, 0.3);
+      cursor: pointer;
+      transition: transform 0.3s ease, box-shadow 0.3s ease;
+    }
+    .mic-button svg {
+      width: 56px;
+      height: 56px;
+    }
+    .mic-button:hover { transform: translateY(-2px); }
+    .mic-button.recording {
+      animation: pulse 1.6s ease-in-out infinite;
+      box-shadow: 0 24px 60px rgba(123, 51, 200, 0.4);
+    }
+    @keyframes pulse {
+      0% { transform: scale(1); }
+      50% { transform: scale(1.08); }
+      100% { transform: scale(1); }
+    }
+
     @media (max-width: 640px) {
       body { padding: 16px; }
       .container { margin-bottom: 24px; }
       .card { padding: 16px; }
       h1 { font-size: 22px; line-height: 1.2; }
       h2 { font-size: 18px; }
       .logo { max-height: 72px; max-width: 100%; height: auto; }
       .btn-row { flex-direction: column; align-items: stretch; }
       .btn { width: 100%; text-align: center; }
       textarea { min-height: 120px; }
+      .mic-button { width: 120px; height: 120px; }
     }
   </style>
 </head>
 <body>
   <div class="container">
     {% if company.logo_path %}
       {% set logo_src = company.logo_path %}
       {% if logo_src.startswith('/') %}
         {% set logo_src = '/voice-feedback' ~ logo_src %}
       {% endif %}
       <img src="{{ logo_src }}" alt="Логотип" class="logo">
     {% endif %}      
     <h1>Отзыв для {{ company.name }}</h1>
     <p>Запишите короткий отзыв, ИИ переведёт его в текст — вы сможете поправить и отправить.</p>
     <div class="card step active" id="step1">
       <h2>Шаг 1. Запишите голосовой отзыв</h2>
       <div class="input-group">
         <label for="userName">Ваше имя (или ник)</label>
-        <input type="text" id="userName" placeholder="Иван">
+        <input type="text" id="userName" placeholder="Введите ваше имя">
       </div>
-      <div class="btn-row">
-        <button id="startBtn" class="btn" type="button">Начать запись</button>
-        <button id="stopBtn" class="btn secondary" type="button" disabled>Остановить</button>
+      <div class="mic-wrapper">
+        <button id="startBtn" class="mic-button" type="button" aria-label="Записать отзыв">
+          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
+            <path d="M12 3a3 3 0 0 0-3 3v6a3 3 0 0 0 6 0V6a3 3 0 0 0-3-3Z" />
+            <path d="M19 10v2a7 7 0 0 1-14 0v-2" />
+            <line x1="12" x2="12" y1="19" y2="22" />
+          </svg>
+        </button>
       </div>
       <div class="info-box">Запись делается через микрофон устройства. Не закрывайте вкладку, пока идёт запись.</div>
       <p id="recordStatus" class="status"></p>
     </div>
 
     <div class="card step" id="step2">
       <h2>Шаг 2. Проверка текста</h2>
       <p><strong>Тональность:</strong> <span id="sentimentSpan"></span></p>
       <p><strong>Текст, который понял ИИ:</strong></p>
       <div class="info-box" id="aiText"></div>
       <div class="btn-row">
         <button id="editBtn" class="btn" type="button">Редактировать и отправить</button>
         <button class="btn secondary" type="button" onclick="showStep(1)">Записать ещё раз</button>
       </div>
     </div>
 
     <div class="card step" id="step3">
       <h2>Шаг 3. Отредактируйте текст и отправьте</h2>
       <textarea id="finalText" placeholder="Добавьте детали или исправьте текст..."></textarea>
       <div class="btn-row">
         <button id="sendBtn" class="btn" type="button">Отправить отзыв</button>
         <button class="btn secondary" type="button" onclick="showStep(1)">Начать заново</button>
       </div>
       <p id="sendStatus" class="status"></p>
     </div>
@@ -158,128 +202,136 @@
     const companySlug = "{{ company.slug }}";
 
     let mediaRecorder;
     let recorderMime;
     let audioChunks = [];
     let useFallback = false;
     let fallbackContext = null;
     let fallbackProcessor = null;
     let fallbackSource = null;
     let fallbackStream = null;
     let fallbackBuffers = [];
     let reviewId = null;
     let normalizedText = "";
 
     const step1 = document.getElementById("step1");
     const step2 = document.getElementById("step2");
     const step3 = document.getElementById("step3");
 
     function showStep(n) {
       [step1, step2, step3].forEach((el, i) => {
         el.classList.toggle("active", i === (n-1));
       });
     }
 
     const startBtn = document.getElementById("startBtn");
-    const stopBtn = document.getElementById("stopBtn");
     const recordStatus = document.getElementById("recordStatus");
     const userNameInput = document.getElementById("userName");
     const aiText = document.getElementById("aiText");
     const sentimentSpan = document.getElementById("sentimentSpan");
     const editBtn = document.getElementById("editBtn");
     const finalText = document.getElementById("finalText");
     const sendBtn = document.getElementById("sendBtn");
     const sendStatus = document.getElementById("sendStatus");
 
+    let isRecording = false;
+
     startBtn.onclick = async () => {
+      if (isRecording) {
+        stopRecording();
+        return;
+      }
+
       audioChunks = [];
       fallbackBuffers = [];
       useFallback = false;
 
       if (typeof MediaRecorder === 'undefined') {
         await startFallbackRecorder();
         return;
       }
 
       let preferredMime = null;
 
       try {
         // 1. Пробуем ogg/opus (идеальный вариант для SpeechKit)
         if (MediaRecorder.isTypeSupported('audio/ogg;codecs=opus')) {
           preferredMime = 'audio/ogg;codecs=opus';
         } else if (MediaRecorder.isTypeSupported('audio/ogg; codecs=opus')) {
           // иногда браузеры чувствительны к пробелам
           preferredMime = 'audio/ogg; codecs=opus';
         }
 
         // 2. Если ogg не поддерживается — пробуем webm/opus (часто так в Chrome)
         if (!preferredMime) {
           if (MediaRecorder.isTypeSupported('audio/webm;codecs=opus')) {
             preferredMime = 'audio/webm;codecs=opus';
           } else if (MediaRecorder.isTypeSupported('audio/webm')) {
             preferredMime = 'audio/webm';
           }
         }
 
         // 3. Если ни один формат не подошёл — включаем ручной рекордер
         if (!preferredMime) {
           await startFallbackRecorder();
           return;
         }
 
         const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
 
         recorderMime = preferredMime;
 
         mediaRecorder = new MediaRecorder(stream, { mimeType: recorderMime });
         mediaRecorder.ondataavailable = (e) => {
           audioChunks.push(e.data);
         };
         mediaRecorder.onstop = onRecordStop;
         mediaRecorder.start();
         recordStatus.textContent = "Запись идёт...";
-        startBtn.disabled = true;
-        stopBtn.disabled = false;
+        startBtn.classList.add("recording");
+        isRecording = true;
       } catch (e) {
         console.error(e);
         await startFallbackRecorder();
       }
     };
 
-    stopBtn.onclick = () => {
+    function stopRecording() {
       if (useFallback) {
         stopFallbackRecorder();
       } else if (mediaRecorder && mediaRecorder.state !== "inactive") {
         mediaRecorder.stop();
       }
-      stopBtn.disabled = true;
-      startBtn.disabled = false;
       recordStatus.textContent = "Обработка записи...";
-    };
+      startBtn.classList.remove("recording");
+      isRecording = false;
+    }
 
     async function onRecordStop() {
       const blob = new Blob(audioChunks, { type: recorderMime || "audio/webm" });
+      startBtn.classList.remove("recording");
+      isRecording = false;
       await uploadAudioBlob(blob, recorderMime || "audio/webm");
     }
 
     async function uploadAudioBlob(blob, mimeType) {
       const formData = new FormData();
 
       let filename = "record.webm";
 
       if (mimeType && mimeType.startsWith("audio/ogg")) {
         filename = "record.ogg";
       } else if (mimeType && mimeType.startsWith("audio/wav")) {
         filename = "record.wav";
       }
 
       formData.append("audio", blob, filename);
       formData.append("user_name", userNameInput.value || "");
 
       recordStatus.textContent = "Обработка записи...";
 
       const res = await fetch(`${BASE}/api/public/${companySlug}/upload-audio`, {
         method: "POST",
         body: formData
       });
 
       if (!res.ok) {
@@ -298,84 +350,86 @@
     }
 
     async function startFallbackRecorder() {
       try {
         const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
         const AudioContextClass = window.AudioContext || window.webkitAudioContext;
 
         fallbackContext = new AudioContextClass();
         fallbackStream = stream;
 
         fallbackSource = fallbackContext.createMediaStreamSource(stream);
         fallbackProcessor = fallbackContext.createScriptProcessor(4096, 1, 1);
         const silentGain = fallbackContext.createGain();
         silentGain.gain.value = 0;
 
         fallbackProcessor.onaudioprocess = (event) => {
           fallbackBuffers.push(new Float32Array(event.inputBuffer.getChannelData(0)));
         };
 
         fallbackSource.connect(fallbackProcessor);
         fallbackProcessor.connect(silentGain);
         silentGain.connect(fallbackContext.destination);
 
         useFallback = true;
         recordStatus.textContent = "Запись идёт...";
-        startBtn.disabled = true;
-        stopBtn.disabled = false;
+        startBtn.classList.add("recording");
+        isRecording = true;
       } catch (error) {
         console.error(error);
         recordStatus.textContent = "Не удалось получить доступ к микрофону.";
       }
     }
 
     function stopFallbackRecorder() {
       if (!fallbackContext || !fallbackProcessor) {
         recordStatus.textContent = "Не удалось завершить запись.";
         return;
       }
 
       fallbackProcessor.disconnect();
       if (fallbackSource) fallbackSource.disconnect();
 
       if (fallbackStream) {
         fallbackStream.getTracks().forEach((track) => track.stop());
       }
 
       const wavBlob = encodeWAV(fallbackBuffers, fallbackContext.sampleRate);
 
       fallbackBuffers = [];
 
       if (fallbackContext && typeof fallbackContext.close === 'function') {
         fallbackContext.close();
       }
 
       fallbackContext = null;
       fallbackProcessor = null;
       fallbackSource = null;
       fallbackStream = null;
 
+      startBtn.classList.remove("recording");
+      isRecording = false;
       uploadAudioBlob(wavBlob, "audio/wav");
     }
 
     function encodeWAV(buffers, sampleRate) {
       const totalLength = buffers.reduce((sum, buffer) => sum + buffer.length, 0);
       const wavBuffer = new ArrayBuffer(44 + totalLength * 2);
       const view = new DataView(wavBuffer);
 
       // RIFF chunk descriptor
       writeString(view, 0, 'RIFF');
       view.setUint32(4, 36 + totalLength * 2, true);
       writeString(view, 8, 'WAVE');
 
       // fmt sub-chunk
       writeString(view, 12, 'fmt ');
       view.setUint32(16, 16, true); // Subchunk1Size
       view.setUint16(20, 1, true); // AudioFormat (PCM)
       view.setUint16(22, 1, true); // NumChannels
       view.setUint32(24, sampleRate, true); // SampleRate
       view.setUint32(28, sampleRate * 2, true); // ByteRate
       view.setUint16(32, 2, true); // BlockAlign
       view.setUint16(34, 16, true); // BitsPerSample
 
       // data sub-chunk
       writeString(view, 36, 'data');
